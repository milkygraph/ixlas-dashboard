// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: order.sql

package db

import (
	"context"
	"time"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO "order" (
    issued_date,
    name,
    surname,
    phone_number,
    language_from,
    language_to,
    number_of_pages,
    notary_id,
    total_payment,
    down_payment,
    remaining,
    translator_id,
    expenses,
    status_id,
    details
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING order_id, issued_date, name, surname, phone_number, language_from, language_to, number_of_pages, notary_id, total_payment, down_payment, remaining, translator_id, expenses, status_id, details
`

type CreateOrderParams struct {
	IssuedDate    time.Time `json:"issued_date"`
	Name          string    `json:"name"`
	Surname       string    `json:"surname"`
	PhoneNumber   string    `json:"phone_number"`
	LanguageFrom  string    `json:"language_from"`
	LanguageTo    string    `json:"language_to"`
	NumberOfPages int32     `json:"number_of_pages"`
	NotaryID      int32     `json:"notary_id"`
	TotalPayment  string    `json:"total_payment"`
	DownPayment   string    `json:"down_payment"`
	Remaining     string    `json:"remaining"`
	TranslatorID  int32     `json:"translator_id"`
	Expenses      string    `json:"expenses"`
	StatusID      int32     `json:"status_id"`
	Details       string    `json:"details"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.IssuedDate,
		arg.Name,
		arg.Surname,
		arg.PhoneNumber,
		arg.LanguageFrom,
		arg.LanguageTo,
		arg.NumberOfPages,
		arg.NotaryID,
		arg.TotalPayment,
		arg.DownPayment,
		arg.Remaining,
		arg.TranslatorID,
		arg.Expenses,
		arg.StatusID,
		arg.Details,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.IssuedDate,
		&i.Name,
		&i.Surname,
		&i.PhoneNumber,
		&i.LanguageFrom,
		&i.LanguageTo,
		&i.NumberOfPages,
		&i.NotaryID,
		&i.TotalPayment,
		&i.DownPayment,
		&i.Remaining,
		&i.TranslatorID,
		&i.Expenses,
		&i.StatusID,
		&i.Details,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM "order" WHERE order_id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, orderID int64) error {
	_, err := q.db.ExecContext(ctx, deleteOrder, orderID)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT order_id, issued_date, name, surname, phone_number, language_from, language_to, number_of_pages, notary_id, total_payment, down_payment, remaining, translator_id, expenses, status_id, details FROM "order" WHERE order_id = $1
`

func (q *Queries) GetOrder(ctx context.Context, orderID int64) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.IssuedDate,
		&i.Name,
		&i.Surname,
		&i.PhoneNumber,
		&i.LanguageFrom,
		&i.LanguageTo,
		&i.NumberOfPages,
		&i.NotaryID,
		&i.TotalPayment,
		&i.DownPayment,
		&i.Remaining,
		&i.TranslatorID,
		&i.Expenses,
		&i.StatusID,
		&i.Details,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT order_id, issued_date, name, surname, phone_number, language_from, language_to, number_of_pages, notary_id, total_payment, down_payment, remaining, translator_id, expenses, status_id, details FROM "order" ORDER BY order_id DESC LIMIT $1 OFFSET $2
`

type GetOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.IssuedDate,
			&i.Name,
			&i.Surname,
			&i.PhoneNumber,
			&i.LanguageFrom,
			&i.LanguageTo,
			&i.NumberOfPages,
			&i.NotaryID,
			&i.TotalPayment,
			&i.DownPayment,
			&i.Remaining,
			&i.TranslatorID,
			&i.Expenses,
			&i.StatusID,
			&i.Details,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersCount = `-- name: GetOrdersCount :one
SELECT COUNT(*) FROM "order"
`

func (q *Queries) GetOrdersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOrdersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE "order" SET
    name = $1,
    surname = $2,
    phone_number = $3,
    language_from = $4,
    language_to = $5,
    number_of_pages = $6,
    notary_id = $7,
    total_payment = $8,
    down_payment = $9,
    remaining = $10,
    translator_id = $11,
    expenses = $12,
    status_id = $13,
    details = $14
WHERE order_id = $15 RETURNING order_id, issued_date, name, surname, phone_number, language_from, language_to, number_of_pages, notary_id, total_payment, down_payment, remaining, translator_id, expenses, status_id, details
`

type UpdateOrderParams struct {
	Name          string `json:"name"`
	Surname       string `json:"surname"`
	PhoneNumber   string `json:"phone_number"`
	LanguageFrom  string `json:"language_from"`
	LanguageTo    string `json:"language_to"`
	NumberOfPages int32  `json:"number_of_pages"`
	NotaryID      int32  `json:"notary_id"`
	TotalPayment  string `json:"total_payment"`
	DownPayment   string `json:"down_payment"`
	Remaining     string `json:"remaining"`
	TranslatorID  int32  `json:"translator_id"`
	Expenses      string `json:"expenses"`
	StatusID      int32  `json:"status_id"`
	Details       string `json:"details"`
	OrderID       int64  `json:"order_id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrder,
		arg.Name,
		arg.Surname,
		arg.PhoneNumber,
		arg.LanguageFrom,
		arg.LanguageTo,
		arg.NumberOfPages,
		arg.NotaryID,
		arg.TotalPayment,
		arg.DownPayment,
		arg.Remaining,
		arg.TranslatorID,
		arg.Expenses,
		arg.StatusID,
		arg.Details,
		arg.OrderID,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.IssuedDate,
		&i.Name,
		&i.Surname,
		&i.PhoneNumber,
		&i.LanguageFrom,
		&i.LanguageTo,
		&i.NumberOfPages,
		&i.NotaryID,
		&i.TotalPayment,
		&i.DownPayment,
		&i.Remaining,
		&i.TranslatorID,
		&i.Expenses,
		&i.StatusID,
		&i.Details,
	)
	return i, err
}
